[{"title":"C语言作业：学生成绩管理系统/C language homework:student performance management system","url":"/2024/04/09/C语言作业：学生成绩管理系统-C-language-homework-student-performance-management-system/","content":"# C语言作业学生成绩管理系统\n\n## 引用头文件及宏定义\n```\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define MAX_COURSES 5\n#define LEN sizeof(struct Student)\n```\n`#include<stdio.h>` 用于输出输入函数\n`#include<stdlib.h>` 包含一些常用的库函数，如内存分配，程序退出等\n`#include<string.h>` 提供了一系列用于处理C字符串的函数，如字符串复制、连接、比较等\n\n`#define MAX_COURSES 5` 定义了最大课程是5，可以看情况自行更改\n`#define LEN sizeof(struct Student)` 定义了一个名为“LEN”的宏，值为“struct Student”结构体的大小，作用是确保内存分配时有足够多的空间来储存一个“Student”结构体的实例\n\n## 定义学生的属性\n```\nstruct Student {\n\tint clas;\n\tint studentNum;\n\tchar name[50];\n\tchar course[50];\n\tint score;\n\tstruct Student *next;\n};\n```\n定义了一个名为“Student”的结构体，用来表示一个学生的信息，其中`struct Student *next;`部分是指向下一个“Student”结构体的指针，为了创建一个链表用来储存学生信息\n\n## 定义主函数\n```\nvoid main(){\n    struct Student *head = NULL;\n    int choice;\n\n    while(1) {\n        printf(\"\\n学生信息管理系统\\n\");\n        printf(\"1. 创建学生信息\\n\");\n        printf(\"2. 显示所有学生信息\\n\");\n        printf(\"3. 添加学生信息\\n\");\n        printf(\"4. 删除学生信息\\n\");\n        printf(\"5. 查找学生信息\\n\");\n        printf(\"6. 更改学生信息\\n\");\n        printf(\"7. 对某课程学生按分数排序\\n\");\n        printf(\"8. 某课程最高分\\n\");\n        printf(\"9. 某课程最低分\\n\");\n        printf(\"10. 计算某课程平均分\\n\");\n        printf(\"11. 计算某课程及格率\\n\");\n        printf(\"0. 退出\\n\");\n        printf(\"请输入你的选择：\");\n        scanf(\"%d\", &choice);\n\n        switch(choice) {\n            case 1: head = creat();break;\n            case 2:show(head);break;\n            case 3:add(head);break;\n            case 4:del(&head);break;\n            case 5:search(head);break;\n            case 6:change(head);break;\n            case 7:sort(head);break;\n            case 8:max(head);break;\n            case 9:min(head);break;\n            case 10:average(head);break;\n            case 11:passRate(head);break;\n            case 0:printf(\"退出系统。\\n\");return 0;\n            default:printf(\"无效选项，请重新输入。\\n\");\n        }\n    }\n}\n```\n是程序执行的入口，先提供选项询问需要执行的操作，然后根据你输入的数字调用相应的函数\n`struct Student *head = NULL;` 通过将“head”指针初始化为“NULL”，开始建立了一个链表，用于储存“Student”结构体的节点\n\n## 接收用户输入的学生信息，构建一个动态的单向链表\n```\nstruct Student *creat(void) {\n    struct Student *head;\n\tstruct Student *ptr1,*ptr2;\n\tint n = 0;\n\tprintf(\"班级      学号      姓名                课程                分数(输入0 0 0 0 0结束)：\\n\");\n\tptr1 = ptr2 = (struct Student*)malloc(LEN);\n\tscanf(\"%d%d%s%s%d\", &ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\thead = NULL;\n\twhile(ptr1->studentNum != 0) {\n\t\tn += 1;\n\t\tif(n == 1) head = ptr1;\n\t\telse ptr2->next = ptr1;\n\t\tptr2 = ptr1;\n\t\tptr1 = (struct Student*)malloc(LEN);\n\t\tscanf(\"%d%d%s%s%d\", &ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\t}\n\tptr2->next = NULL;\n\treturn(head);\n};\n```\n用“head”储存链表的头部，ptr1 和 ptr2 分别用作新节点的指针和当前链表末尾节点的指针，n 用来记录链表中节点的数量\n用“malloc”分配一个新的 Student 结构体的内存给 ptr1 和 ptr2，LEN 是通过 sizeof(struct Student) 定义的，确保为一个 Student 结构体分配足够的内存\n通过 `scanf` 函数读取用户输入的学生信息，直到用户输入一系列 0 值作为结束标记\n链表构建：\n* 如果是第一个节点（n == 1），则将 head 指向这个新节点\n* 如果不是第一个节点，则将上一个节点的 next 指向当前节点`（ptr2->next = ptr1）`\n* ptr2 总是跟踪最后一个节点，而 ptr1 用于创建和读取下一个节点的数据\n当输入结束标记后，设置链表的最后一个节点的 next 指针为 NULL，表示链表结束\n\n## 对内容进行显示输出\n```\nvoid show(struct Student *ptr) {\n\tprintf(\"班级      学号      姓名                课程                分数：\\n\");\n\twhile (ptr != NULL) {\n        printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", ptr->clas, ptr->studentNum, ptr->name, ptr->course, ptr->score);\n        ptr = ptr->next;\n\t}\n\tprintf(\"\\n\");\n}\n```\n这个函数的形参 `struct Student *ptr` 是一个指向“Studen”t结构体的指针，作为函数的入口，用于接收链表的头节点指针\n当指针非空的时候进行循环，对学生信息依次输出\n\n## 增和删\n```\nvoid add(struct Student *ptr) {\n    struct Student *ptr1,*ptr2,*head;\n\thead = ptr;\n\tprintf(\"输入要添加的学生信息:\\n\");\n\twhile(ptr->next != NULL) ptr = ptr->next;\n\tptr1 = ptr2 = ptr;\n\tprintf(\"班级      学号      姓名                课程                分数(输入0 0 0 0 0结束)：\\n\");\n\tdo {\n\t\tptr1 = (struct Student*)malloc(LEN);\n\t\tscanf(\"%d%d%s%s%d\",&ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\t\tptr2->next = ptr1;\n\t\tptr2 = ptr1;\n\t} while(ptr1->studentNum != 0);\n\tptr2->next = NULL;\n\tshow(head);\n}\n\nvoid del(struct Student **head) {\n    int n;\n    printf(\"输入要删除的学生的学号：\\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head, *prev = NULL;\n\n    if (temp != NULL && temp->studentNum == n) {\n        *head = temp->next;\n        free(temp);\n        printf(\"已删除学号为 %d 的学生信息\\n\", n);\n        printf(\"\\n\");\n        return;\n    }\n\n    while (temp != NULL && temp->studentNum != n) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) {\n        printf(\"学号为 %d 的学生未找到\\n\", n);\n        printf(\"\\n\");\n        return;\n    }\n\n    prev->next = temp->next;\n\n    free(temp);\n\n    printf(\"已删除学号为 %d 的学生信息\\n\", n);\n    printf(\"\\n\");\n    show(*head);\n}\n```\n通过“do-while”循环允许用户连续输入学生信息，每次循环都会通过“malloc”动态分配一个新的“Student”结构体内存，并通过“scanf”读取用户输入的学生信息\n对于新输入的学生信息，更新链表的“next”指针，将新分配的结构体节点添加到链表末端”ptr2“始终指向链表最后一个节点\n最后设置“ptr2->next = NULL”以确保链表正确终止，并在“do-while”循环外部删除了这个多余的节点\n搜索并删除：\n* 如果头节点就是要删除的节点，函数会更新头节点指针“*head”指向下一个节点，然后释放原头节点的内存，并通知用户已删除该学生信息\n* 如果头节点不是要删除的节点，函数会遍历链表，直到找到匹配的“studentNum”或到达链表尾部，在遍历过程中，“prev”指针用于跟踪当前节点的前一个节点，而“temp”指针跟踪当前正在检查的节点\n* 如果遍历完整个链表都没有找到匹配的学号，函数会通知用户未找到指定学号的学生\n* 找到目标节点后，通过调整前一个节点的 next 指针绕过当前节点“temp”，直接指向`temp->next`，从而从链表中移除当前节点,然后释放该节点的内存\n\n## 查和改\n```\n//查\nvoid search(struct Student *ptr) {\n    void searchByNum(struct Student **head);\n\tvoid searchByName(struct Student **head);\n\tvoid searchByCourse(struct Student **head);\n\tint n;\n\tprintf(\"\\n\");\n\tprintf(\"请输入你要查询学生的 1 学号 2 姓名 3 课程名：\\n\");\n\tscanf(\"%d\",&n);\n\tswitch(n) {\n\tcase 1:searchByNum(&ptr);break;\n\tcase 2:searchByName(&ptr);break;\n\tcase 3:searchByCourse(&ptr);break;\n\tdefault:printf(\"无此选项!\\n\");\n\t}\n}\n\n//查学号\n\nvoid searchByNum(struct Student **head) {\n    int n;\n    printf(\"\\n输入要查询的学生的学号：\\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"班级      学号      姓名                课程                分数：\\n\");\n    while (temp != NULL) {\n        if (temp->studentNum == n) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"学号为 %d 的学生未找到\\n\", n);\n}\n\n//查名字\nvoid searchByName(struct Student **head) {\n    char name[50];\n    printf(\"\\n请输入你要查询学生的姓名：\\n\");\n    scanf(\"%50s\", name);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"班级      学号      姓名                课程                分数：\\n\");\n    while (temp != NULL) {\n        if (strcmp(temp->name, name) == 0) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"名字为 %s 的学生未找到\\n\", name);\n}\n\n//查课程\nvoid searchByCourse(struct Student **head) {\n    char course[50];\n    printf(\"\\n请输入你要查询的课程：\\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"班级      学号      姓名                课程                分数：\\n\");\n    while (temp != NULL) {\n        if (strcmp(temp->course, course) == 0) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"课程 %s 没有学生\\n\", course);\n}\n\n//改\nvoid change(struct Student *ptr) {\n    void changeNum(struct Student **head);\n\tvoid changeName(struct Student **head);\n\tvoid changeSco(struct Student **head);\n\tint n;\n\tprintf(\"\\n\");\n\tprintf(\"请输入你要更改学生的 1 学号 2 姓名 3 分数：\\n\");\n\tscanf(\"%d\",&n);\n\tswitch(n) {\n\tcase 1:changeNum(&ptr);break;\n\tcase 2:changeName(&ptr);break;\n\tcase 3:changeSco(&ptr);break;\n\tdefault:printf(\"无此选项!\\n\");\n\t}\n}\n\n//改学号\nvoid changeNum(struct Student **head) {\n    int oldNum, newNum;\n    printf(\"\\n输入要更改的学生的学号：\\n\");\n    scanf(\"%d\", &oldNum);\n    printf(\"\\n将此学号更改为：\\n\");\n    scanf(\"%d\", &newNum);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    while (temp != NULL) {\n        if (temp->studentNum == oldNum) {\n            temp->studentNum = newNum;\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"学号为 %d 的学生未找到\\n\", oldNum);\n    else show(*head);\n}\n\n//改名字\nvoid changeName(struct Student **head) {\n    char name[50];\n    char newName[50];\n    printf(\"\\n输入要更改的学生的名字：\\n\");\n    scanf(\"%50s\", &name);\n    printf(\"\\n将此名字更改为：\\n\");\n    scanf(\"%50s\", &newName);\n    struct Student *temp = *head;\n\n    while (temp != NULL && strcmp(temp->name, name) != 0) temp = temp->next;\n\n    if (temp == NULL) printf(\"名字为 %s 的学生未找到\\n\", name);\n    else strcpy(temp->name, newName);\n    show(*head);\n}\n\n//改分数\nvoid changeSco(struct Student **head) {\n    int n, newSco;\n    char course[50];\n    printf(\"\\n输入要更改分数的学生的学号：\\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head;\n\n    while (temp != NULL && temp->studentNum != n) temp = temp->next;\n\n    if (temp == NULL) printf(\"学号为 %d 的学生未找到\\n\", n);\n    else {\n        printf(\"\\n输入要更改分数的学生的学科：\\n\");\n        scanf(\"%49s\", course);\n\n        int courseFound = 0;\n        for (int i = 0; i < MAX_COURSES; ++i) {\n            if (strcmp(temp->course, course) == 0) {\n                printf(\"\\n输入新的分数：\\n\");\n                scanf(\"%d\", &newSco);\n\n                temp->score = newSco;\n                courseFound = 1;\n                break;\n            }\n        }\n\n        if (!courseFound) printf(\"未找到学科 %s\\n\", course);\n        else printf(\"学号 %d 的学生在学科 %s 的分数已更新为 %d\\n\", temp->studentNum, course, newSco);\n    }\n    show(*head);\n}\n```\n\n通过遍历链表，比较每个节点和需要查询的内容是否相同\n通过遍历链表，查找到需要更改的信息，将需要更改的信息替换为新的信息\n\n## 排序\n\n```\n//排序\nvoid sort(struct Student *head) {\n    char courseToSort[50];\n    struct Student *sortedList = NULL;\n    struct Student *temp, *newNode;\n\n    printf(\"\\n请输入要排序的课程名称：\\n\");\n    scanf(\"%50s\", courseToSort);\n\n    temp = head;\n    while (temp != NULL) {\n        if (strcmp(temp->course, courseToSort) == 0) {\n            newNode = (struct Student*)malloc(LEN);\n            *newNode = *temp;\n            newNode->next = sortedList;\n            sortedList = newNode;\n        }\n        temp = temp->next;\n    }\n\n    bubbleSort(&sortedList);\n\n    printf(\"排序后的学生信息：\\n\");\n    show(sortedList);\n\n    while (sortedList != NULL) {\n        temp = sortedList;\n        sortedList = sortedList->next;\n        free(temp);\n    }\n}\n\nvoid bubbleSort(struct Student **head) {\n    int swapped;\n    struct Student *ptr1;\n    struct Student *lptr = NULL;\n\n    if (*head == NULL) return;\n\n    do {\n        swapped = 0;\n        ptr1 = *head;\n\n        while (ptr1->next != lptr) {\n            if (ptr1->score < ptr1->next->score) {\n                swap(ptr1, ptr1->next);\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    } while (swapped);\n}\n\nvoid swap(struct Student *a, struct Student *b) {\n    int tempClass = a->clas;\n    int tempStudentNum = a->studentNum;\n    char tempName[50];\n    strcpy(tempName, a->name);\n    char tempCourse[50];\n    strcpy(tempCourse, a->course);\n    int tempScore = a->score;\n\n    a->clas = b->clas;\n    a->studentNum = b->studentNum;\n    strcpy(a->name, b->name);\n    strcpy(a->course, b->course);\n    a->score = b->score;\n\n    b->clas = tempClass;\n    b->studentNum = tempStudentNum;\n    strcpy(b->name, tempName);\n    strcpy(b->course, tempCourse);\n    b->score = tempScore;\n}\n\nstruct Student *createSubjectList(struct Student *head, char *course) {\n    struct Student *newList = NULL, *temp, *newNode;\n    temp = head;\n    while (temp != NULL) {\n        if (strcmp(temp->course, course) == 0) {\n            newNode = (struct Student*)malloc(LEN);\n            *newNode = *temp;\n            newNode->next = newList;\n            newList = newNode;\n        }\n        temp = temp->next;\n    }\n    return newList;\n}\n```\n通过`struct Student *createSubjectList(struct Student *head, char *course);`定义了一个新的链表用于储存排序后的结果\n通过`void swap(struct Student *a, struct Student *b);`定义了一个交换两个学生所有信息的位置的函数，便于冒泡排序的交换位置的操作\n通过`void bubbleSort(struct Student **head);`定义了一个冒泡排序，通过对比分数进行排序\n通过`void sort(struct Student *head);`获取需要排序的学科，将原链表中该学科的信息储存到新链表，并对新链表进行排序，然后再进行输出\n\n## 最高分和最低分\n```\n//最高分\nvoid max(struct Student *head) {\n    char course[50];\n    printf(\"\\n输入要查询最高分的课程：\\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *subjectList = createSubjectList(head, course), *temp;\n    int maxScore = -1;\n\n    temp = subjectList;\n    while (temp != NULL) {\n        if (temp->score > maxScore) maxScore = temp->score;\n        temp = temp->next;\n    }\n\n    if (maxScore == -1) printf(\"课程 %s 没有学生\\n\", course);\n    else printf(\"课程 %s 的最高分是 %d\\n\", course, maxScore);\n\n    while (subjectList != NULL) {\n        temp = subjectList;\n        subjectList = subjectList->next;\n        free(temp);\n    }\n}\n\n//最低分\nvoid min(struct Student *head) {\n    char course[50];\n    printf(\"\\n输入要查询最高分的课程：\\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *subjectList = createSubjectList(head, course), *temp;\n    int minScore = 101;\n\n    temp = subjectList;\n    while (temp != NULL) {\n        if (temp->score < minScore) minScore = temp->score;\n        temp = temp->next;\n    }\n\n    if (minScore == -1) printf(\"课程 %s 没有学生\\n\", course);\n    else printf(\"课程 %s 的最低分是 %d\\n\", course, minScore);\n\n    while (subjectList != NULL) {\n        temp = subjectList;\n        subjectList = subjectList->next;\n        free(temp);\n    }\n}\n```\n获取需要查询最高分的学科，创建新链表，并将要查询学科的信息储存在新链表中，在新链表中对比，并获取最高分\n最低分同理\n\n## 平均分和及格率\n```\n//平均分\nvoid average(struct Student *head) {\n    char course[50];\n    printf(\"\\n输入要查询平均分的课程：\\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *subjectList = createSubjectList(head, course), *temp;\n    int totalScore = 0, count = 0;\n\n    temp = subjectList;\n    while (temp != NULL) {\n        totalScore += temp->score;\n        count++;\n        temp = temp->next;\n    }\n\n    if (count == 0) printf(\"课程 %s 没有学生\\n\", course);\n    else printf(\"课程 %s 的平均分是 %.2f\\n\", course, (float)totalScore / count);\n\n    while (subjectList != NULL) {\n        temp = subjectList;\n        subjectList = subjectList->next;\n        free(temp);\n    }\n}\n\n// 及格率\nvoid passRate(struct Student *head) {\n\n    char course[50];\n    printf(\"\\n输入要查询平均分的课程：\\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *subjectList = createSubjectList(head, course), *temp;\n    int passCount = 0, count = 0;\n\n    temp = subjectList;\n    while (temp != NULL) {\n        if (temp->score >= 60) passCount++;\n        count++;\n        temp = temp->next;\n    }\n\n    if (count == 0) printf(\"课程 %s 没有学生\\n\", course);\n    else printf(\"课程 %s 的及格率是 %.2f\\n\", course, (float)passCount / count);\n\n    while (subjectList != NULL) {\n        temp = subjectList;\n        subjectList = subjectList->next;\n        free(temp);\n    }\n}\n```\n获取到需要计算平均分的学科，创建新链表储存该学科的信息并计算分数总和和有多少学生，最后在输出平均分\n及格率同理\n\n## 源代码\n```\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define MAX_COURSES 5\n#define LEN sizeof(struct Student)\n\n//定义学生属性\nstruct Student {\n\tint clas;\n\tint studentNum;\n\tchar name[50];\n\tchar course[50];\n\tint score;\n\tstruct Student *next;\n};\nstruct Student *creat(void);\nvoid show(struct Student *ptr);\nvoid add(struct Student *ptr);\nvoid del(struct Student **head);\nvoid search(struct Student *ptr);\nvoid searchByNum(struct Student **head);\nvoid searchByName(struct Student **head);\nvoid searchByCourse(struct Student **head);\nvoid change(struct Student *ptr);\nvoid changeNum(struct Student **head);\nvoid changeName(struct Student **head);\nvoid changeSco(struct Student **head);\nvoid sort(struct Student *head);\nvoid bubbleSort(struct Student **head);\nvoid swap(struct Student *a, struct Student *b);\nstruct Student *createSubjectList(struct Student *head, char *course);\nvoid max(struct Student *head);\nvoid min(struct Student *head);\nvoid average(struct Student *head);\nvoid passRate(struct Student *head);\n\n//主函数\nvoid main(){\n    struct Student *head = NULL;\n    int choice;\n\n    while(1) {\n        printf(\"\\n学生信息管理系统\\n\");\n        printf(\"1. 创建学生信息\\n\");\n        printf(\"2. 显示所有学生信息\\n\");\n        printf(\"3. 添加学生信息\\n\");\n        printf(\"4. 删除学生信息\\n\");\n        printf(\"5. 查找学生信息\\n\");\n        printf(\"6. 更改学生信息\\n\");\n        printf(\"7. 对某课程学生按分数排序\\n\");\n        printf(\"8. 某课程最高分\\n\");\n        printf(\"9. 某课程最低分\\n\");\n        printf(\"10. 计算某课程平均分\\n\");\n        printf(\"11. 计算某课程及格率\\n\");\n        printf(\"0. 退出\\n\");\n        printf(\"请输入你的选择：\");\n        scanf(\"%d\", &choice);\n\n        switch(choice) {\n            case 1: head = creat();break;\n            case 2:show(head);break;\n            case 3:add(head);break;\n            case 4:del(&head);break;\n            case 5:search(head);break;\n            case 6:change(head);break;\n            case 7:sort(head);break;\n            case 8:max(head);break;\n            case 9:min(head);break;\n            case 10:average(head);break;\n            case 11:passRate(head);break;\n            case 0:printf(\"退出系统。\\n\");return 0;\n            default:printf(\"无效选项，请重新输入。\\n\");\n        }\n    }\n}\n\nstruct Student *creat(void) {\n    struct Student *head;\n\tstruct Student *ptr1,*ptr2;\n\tint n = 0;\n\tprintf(\"班级      学号      姓名                课程                分数(输入0 0 0 0 0结束)：\\n\");\n\tptr1 = ptr2 = (struct Student*)malloc(LEN);\n\tscanf(\"%d%d%s%s%d\", &ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\thead = NULL;\n\twhile(ptr1->studentNum != 0) {\n\t\tn += 1;\n\t\tif(n == 1) head = ptr1;\n\t\telse ptr2->next = ptr1;\n\t\tptr2 = ptr1;\n\t\tptr1 = (struct Student*)malloc(LEN);\n\t\tscanf(\"%d%d%s%s%d\", &ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\t}\n\tptr2->next = NULL;\n\treturn(head);\n};\n\n//显示内容\nvoid show(struct Student *ptr) {\n\tprintf(\"班级      学号      姓名                课程                分数：\\n\");\n\twhile (ptr != NULL) {\n        printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", ptr->clas, ptr->studentNum, ptr->name, ptr->course, ptr->score);\n        ptr = ptr->next;\n\t}\n\tprintf(\"\\n\");\n}\n\n//增\nvoid add(struct Student *ptr) {\n    struct Student *ptr1,*ptr2,*head;\n\thead = ptr;\n\tprintf(\"输入要添加的学生信息:\\n\");\n\twhile(ptr->next != NULL) ptr = ptr->next;\n\tptr1 = ptr2 = ptr;\n\tprintf(\"班级      学号      姓名                课程                分数(输入0 0 0 0 0结束)：\\n\");\n\tdo {\n\t\tptr1 = (struct Student*)malloc(LEN);\n\t\tscanf(\"%d%d%s%s%d\",&ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\t\tptr2->next = ptr1;\n\t\tptr2 = ptr1;\n\t} while(ptr1->studentNum != 0);\n\tptr2->next = NULL;\n\tshow(head);\n}\n\n//删\nvoid del(struct Student **head) {\n    int n;\n    printf(\"输入要删除的学生的学号：\\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head, *prev = NULL;\n\n    if (temp != NULL && temp->studentNum == n) {\n        *head = temp->next;\n        free(temp);\n        printf(\"已删除学号为 %d 的学生信息\\n\", n);\n        printf(\"\\n\");\n        return;\n    }\n\n    while (temp != NULL && temp->studentNum != n) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) {\n        printf(\"学号为 %d 的学生未找到\\n\", n);\n        printf(\"\\n\");\n        return;\n    }\n\n    prev->next = temp->next;\n\n    free(temp);\n\n    printf(\"已删除学号为 %d 的学生信息\\n\", n);\n    printf(\"\\n\");\n    show(*head);\n}\n\n//查\nvoid search(struct Student *ptr) {\n    void searchByNum(struct Student **head);\n\tvoid searchByName(struct Student **head);\n\tvoid searchByCourse(struct Student **head);\n\tint n;\n\tprintf(\"\\n\");\n\tprintf(\"请输入你要查询学生的 1 学号 2 姓名 3 课程名：\\n\");\n\tscanf(\"%d\",&n);\n\tswitch(n) {\n\tcase 1:searchByNum(&ptr);break;\n\tcase 2:searchByName(&ptr);break;\n\tcase 3:searchByCourse(&ptr);break;\n\tdefault:printf(\"无此选项!\\n\");\n\t}\n}\n\n//查学号\n\nvoid searchByNum(struct Student **head) {\n    int n;\n    printf(\"\\n输入要查询的学生的学号：\\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"班级      学号      姓名                课程                分数：\\n\");\n    while (temp != NULL) {\n        if (temp->studentNum == n) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"学号为 %d 的学生未找到\\n\", n);\n}\n\n//查名字\nvoid searchByName(struct Student **head) {\n    char name[50];\n    printf(\"\\n请输入你要查询学生的姓名：\\n\");\n    scanf(\"%50s\", name);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"班级      学号      姓名                课程                分数：\\n\");\n    while (temp != NULL) {\n        if (strcmp(temp->name, name) == 0) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"名字为 %s 的学生未找到\\n\", name);\n}\n\n//查课程\nvoid searchByCourse(struct Student **head) {\n    char course[50];\n    printf(\"\\n请输入你要查询的课程：\\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"班级      学号      姓名                课程                分数：\\n\");\n    while (temp != NULL) {\n        if (strcmp(temp->course, course) == 0) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"课程 %s 没有学生\\n\", course);\n}\n\n//改\nvoid change(struct Student *ptr) {\n    void changeNum(struct Student **head);\n\tvoid changeName(struct Student **head);\n\tvoid changeSco(struct Student **head);\n\tint n;\n\tprintf(\"\\n\");\n\tprintf(\"请输入你要更改学生的 1 学号 2 姓名 3 分数：\\n\");\n\tscanf(\"%d\",&n);\n\tswitch(n) {\n\tcase 1:changeNum(&ptr);break;\n\tcase 2:changeName(&ptr);break;\n\tcase 3:changeSco(&ptr);break;\n\tdefault:printf(\"无此选项!\\n\");\n\t}\n}\n\n//改学号\nvoid changeNum(struct Student **head) {\n    int oldNum, newNum;\n    printf(\"\\n输入要更改的学生的学号：\\n\");\n    scanf(\"%d\", &oldNum);\n    printf(\"\\n将此学号更改为：\\n\");\n    scanf(\"%d\", &newNum);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    while (temp != NULL) {\n        if (temp->studentNum == oldNum) {\n            temp->studentNum = newNum;\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"学号为 %d 的学生未找到\\n\", oldNum);\n    else show(*head);\n}\n\n//改名字\nvoid changeName(struct Student **head) {\n    char name[50];\n    char newName[50];\n    printf(\"\\n输入要更改的学生的名字：\\n\");\n    scanf(\"%50s\", &name);\n    printf(\"\\n将此名字更改为：\\n\");\n    scanf(\"%50s\", &newName);\n    struct Student *temp = *head;\n\n    while (temp != NULL && strcmp(temp->name, name) != 0) temp = temp->next;\n\n    if (temp == NULL) printf(\"名字为 %s 的学生未找到\\n\", name);\n    else strcpy(temp->name, newName);\n    show(*head);\n}\n\n//改分数\nvoid changeSco(struct Student **head) {\n    int n, newSco;\n    char course[50];\n    printf(\"\\n输入要更改分数的学生的学号：\\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head;\n\n    while (temp != NULL && temp->studentNum != n) temp = temp->next;\n\n    if (temp == NULL) printf(\"学号为 %d 的学生未找到\\n\", n);\n    else {\n        printf(\"\\n输入要更改分数的学生的学科：\\n\");\n        scanf(\"%49s\", course);\n\n        int courseFound = 0;\n        for (int i = 0; i < MAX_COURSES; ++i) {\n            if (strcmp(temp->course, course) == 0) {\n                printf(\"\\n输入新的分数：\\n\");\n                scanf(\"%d\", &newSco);\n\n                temp->score = newSco;\n                courseFound = 1;\n                break;\n            }\n        }\n\n        if (!courseFound) printf(\"未找到学科 %s\\n\", course);\n        else printf(\"学号 %d 的学生在学科 %s 的分数已更新为 %d\\n\", temp->studentNum, course, newSco);\n    }\n    show(*head);\n}\n\n//排序\nvoid sort(struct Student *head) {\n    char courseToSort[50];\n    struct Student *sortedList = NULL;\n    struct Student *temp, *newNode;\n\n    printf(\"\\n请输入要排序的课程名称：\\n\");\n    scanf(\"%50s\", courseToSort);\n\n    temp = head;\n    while (temp != NULL) {\n        if (strcmp(temp->course, courseToSort) == 0) {\n            newNode = (struct Student*)malloc(LEN);\n            *newNode = *temp;\n            newNode->next = sortedList;\n            sortedList = newNode;\n        }\n        temp = temp->next;\n    }\n\n    bubbleSort(&sortedList);\n\n    printf(\"排序后的学生信息：\\n\");\n    show(sortedList);\n\n    while (sortedList != NULL) {\n        temp = sortedList;\n        sortedList = sortedList->next;\n        free(temp);\n    }\n}\n\nvoid bubbleSort(struct Student **head) {\n    int swapped;\n    struct Student *ptr1;\n    struct Student *lptr = NULL;\n\n    if (*head == NULL) return;\n\n    do {\n        swapped = 0;\n        ptr1 = *head;\n\n        while (ptr1->next != lptr) {\n            if (ptr1->score < ptr1->next->score) {\n                swap(ptr1, ptr1->next);\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    } while (swapped);\n}\n\nvoid swap(struct Student *a, struct Student *b) {\n    int tempClass = a->clas;\n    int tempStudentNum = a->studentNum;\n    char tempName[50];\n    strcpy(tempName, a->name);\n    char tempCourse[50];\n    strcpy(tempCourse, a->course);\n    int tempScore = a->score;\n\n    a->clas = b->clas;\n    a->studentNum = b->studentNum;\n    strcpy(a->name, b->name);\n    strcpy(a->course, b->course);\n    a->score = b->score;\n\n    b->clas = tempClass;\n    b->studentNum = tempStudentNum;\n    strcpy(b->name, tempName);\n    strcpy(b->course, tempCourse);\n    b->score = tempScore;\n}\n\nstruct Student *createSubjectList(struct Student *head, char *course) {\n    struct Student *newList = NULL, *temp, *newNode;\n    temp = head;\n    while (temp != NULL) {\n        if (strcmp(temp->course, course) == 0) {\n            newNode = (struct Student*)malloc(LEN);\n            *newNode = *temp;\n            newNode->next = newList;\n            newList = newNode;\n        }\n        temp = temp->next;\n    }\n    return newList;\n}\n\n//最高分\nvoid max(struct Student *head) {\n    char course[50];\n    printf(\"\\n输入要查询最高分的课程：\\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *subjectList = createSubjectList(head, course), *temp;\n    int maxScore = -1;\n\n    temp = subjectList;\n    while (temp != NULL) {\n        if (temp->score > maxScore) maxScore = temp->score;\n        temp = temp->next;\n    }\n\n    if (maxScore == -1) printf(\"课程 %s 没有学生\\n\", course);\n    else printf(\"课程 %s 的最高分是 %d\\n\", course, maxScore);\n\n    while (subjectList != NULL) {\n        temp = subjectList;\n        subjectList = subjectList->next;\n        free(temp);\n    }\n}\n\n//最低分\nvoid min(struct Student *head) {\n    char course[50];\n    printf(\"\\n输入要查询最高分的课程：\\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *subjectList = createSubjectList(head, course), *temp;\n    int minScore = 101;\n\n    temp = subjectList;\n    while (temp != NULL) {\n        if (temp->score < minScore) minScore = temp->score;\n        temp = temp->next;\n    }\n\n    if (minScore == -1) printf(\"课程 %s 没有学生\\n\", course);\n    else printf(\"课程 %s 的最低分是 %d\\n\", course, minScore);\n\n    while (subjectList != NULL) {\n        temp = subjectList;\n        subjectList = subjectList->next;\n        free(temp);\n    }\n}\n\n//平均分\nvoid average(struct Student *head) {\n    char course[50];\n    printf(\"\\n输入要查询平均分的课程：\\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *subjectList = createSubjectList(head, course), *temp;\n    int totalScore = 0, count = 0;\n\n    temp = subjectList;\n    while (temp != NULL) {\n        totalScore += temp->score;\n        count++;\n        temp = temp->next;\n    }\n\n    if (count == 0) printf(\"课程 %s 没有学生\\n\", course);\n    else printf(\"课程 %s 的平均分是 %.2f\\n\", course, (float)totalScore / count);\n\n    while (subjectList != NULL) {\n        temp = subjectList;\n        subjectList = subjectList->next;\n        free(temp);\n    }\n}\n\n// 及格率\nvoid passRate(struct Student *head) {\n\n    char course[50];\n    printf(\"\\n输入要查询平均分的课程：\\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *subjectList = createSubjectList(head, course), *temp;\n    int passCount = 0, count = 0;\n\n    temp = subjectList;\n    while (temp != NULL) {\n        if (temp->score >= 60) passCount++;\n        count++;\n        temp = temp->next;\n    }\n\n    if (count == 0) printf(\"课程 %s 没有学生\\n\", course);\n    else printf(\"课程 %s 的及格率是 %.2f\\n\", course, (float)passCount / count);\n\n    while (subjectList != NULL) {\n        temp = subjectList;\n        subjectList = subjectList->next;\n        free(temp);\n    }\n}\n```\n\n## chatgpt的评价\n我将这段代码喂给了chatgpt，让它进行了一下评价，评价结果如下\n### 优点\n* 功能全面：程序涵盖了学生信息管理系统的核心功能，如增加、删除、查询、排序及统计等，较为全面地满足了基本管理需求。\n* 模块化设计：通过将功能拆分成多个独立的函数，提高了代码的可读性和可维护性。这种模块化设计使得对单独功能的修改和扩展变得更加容易。\n* 链表数据结构：采用链表来管理学生信息，链表是一种动态数据结构，它可以有效地支持数据的动态增删操作，内存使用更为灵活。\n### 不足\n* 数据持久化未实现：程序未提供数据的持久化机制，所有数据保存在内存中，程序关闭后数据将丢失。这在实际应用中是一个显著的缺陷。\n* 错误处理有待加强：程序在输入错误或异常情况下的容错性不足，未提供足够的错误处理机制，可能导致程序异常退出或运行时错误。\n* 界面交互简陋：尽管不考虑图形化界面，但程序的命令行交互界面仍显得较为简陋，缺少指引和输入提示，可能影响用户体验。\n* 效率问题：在处理大量数据时，使用简单的链表结构和基本的排序算法可能效率不高，特别是对于排序和查找功能。\n### 改进建议\n* 引入数据持久化：通过将数据保存到文件（如文本文件、CSV文件等），实现数据的持久化存储。在程序启动时加载文件中的数据，退出时保存数据到文件，以保证数据不会因程序关闭而丢失。\n* 增强错误处理与输入验证：对用户输入进行严格验证，确保输入的数据合法性和正确性。对潜在的错误情况进行预判和处理，提高程序的稳定性和容错性。\n* 优化数据结构和算法：针对数据量大的情况，可以考虑使用更高效的数据结构（如散列、平衡树等）来管理数据。同时，对于排序和查找等操作，采用更高效的算法（如快速排序、二分查找等）以提升性能。\n* 改进用户交互设计：即便是在命令行界面下，也可以通过更友好的提示信息、清晰的操作指引以及简化的操作步骤来改善用户体验。例如，提供操作成功或错误的明确反馈，简化复杂的输入过程。\n—---------------------\n\n# C language homework student performance management system\n\n## Reference header files and macro definitions\n```\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define MAX_COURSES 5\n#define LEN sizeof(struct Student)\n```\n`#include<stdio.h>` is used to output input functions\n`#include<stdlib.h>` contains some commonly used library functions, such as memory allocation, program exit, etc.\n`#include<string.h>` provides a series of functions for processing C strings, such as string copying, concatenation, comparison, etc.\n\n`#define MAX_COURSES 5` defines the maximum course is 5, which can be changed according to the situation.\n`#define LEN sizeof(struct Student)` defines a macro named \"LEN\", whose value is the size of the \"struct Student\" structure. Its function is to ensure that there is enough space to store a \"Student\" structure when memory is allocated. Examples of bodies\n\n## Define student attributes\n```\nstruct Student {\n\tint clas;\n\tint studentNum;\n\tchar name[50];\n\tchar course[50];\n\tint score;\n\tstruct Student *next;\n};\n```\nA structure named \"Student\" is defined to represent a student's information. The `struct Student *next;` part is a pointer to the next \"Student\" structure in order to create a linked list to store student information.\n\n## Define main function\n```\nvoid main(){\n    struct Student *head = NULL;\n    int choice;\n\n    while(1) {\n        printf(\"\\nStudent Information Management System\\n\");\n        printf(\"1. Create student information\\n\");\n        printf(\"2. Display all student information\\n\");\n        printf(\"3. Add student information\\n\");\n        printf(\"4. Delete student information\\n\");\n        printf(\"5. Search for student information\\n\");\n        printf(\"6. Modify student information\\n\");\n        printf(\"7. Sort students by score for a course\\n\");\n        printf(\"8. Highest score for a course\\n\");\n        printf(\"9. Lowest score for a course\\n\");\n        printf(\"10. Calculate average score for a course\\n\");\n        printf(\"11. Calculate passing rate for a course\\n\");\n        printf(\"0. Exit\\n\");\n        printf(\"Please enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch(choice) {\n            case 1: head = create();break;\n            case 2: display(head);break;\n            case 3: add(head);break;\n            case 4: delete(&head);break;\n            case 5: search(head);break;\n            case 6: modify(head);break;\n            case 7: sort(head);break;\n            case 8: maximum(head);break;\n            case 9: minimum(head);break;\n            case 10: average(head);break;\n            case 11: passingRate(head);break;\n            case 0: printf(\"Exiting system.\\n\"); return 0;\n            default: printf(\"Invalid option, please re-enter.\\n\");\n        }\n    }\n}\n```\nIt is the entry point for program execution. It first provides options to ask for the operations that need to be performed, and then calls the corresponding function based on the number you entered.\n`struct Student *head = NULL;` By initializing the \"head\" pointer to \"NULL\", a linked list is built to store the nodes of the \"Student\" structure\n\n## Receive student information entered by the user and build a dynamic one-way linked list\n```\nstruct Student *create(void) {\n    struct Student *head;\n\tstruct Student *ptr1,*ptr2;\n\tint n = 0;\n\tprintf(\"Class    Student Number    Name                Course                Score(enter 0 0 0 0 0 to end): \\n\");\n\tptr1 = ptr2 = (struct Student*)malloc(LEN);\n\tscanf(\"%d%d%s%s%d\", &ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\thead = NULL;\n\twhile(ptr1->studentNum != 0) {\n\t\tn += 1;\n\t\tif(n == 1) head = ptr1;\n\t\telse ptr2->next = ptr1;\n\t\tptr2 = ptr1;\n\t\tptr1 = (struct Student*)malloc(LEN);\n\t\tscanf(\"%d%d%s%s%d\", &ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\t}\n\tptr2->next = NULL;\n\treturn(head);\n};\n```\nUse \"head\" to store the head of the linked list. ptr1 and ptr2 are used as pointers to new nodes and pointers to the end node of the current linked list respectively. n is used to record the number of nodes in the linked list.\nUse \"malloc\" to allocate the memory of a new Student structure to ptr1 and ptr2. LEN is defined by sizeof(struct Student) to ensure that sufficient memory is allocated for a Student structure.\nRead the student information entered by the user through the `scanf` function until the user enters a series of 0 values as the end mark\nLinked list construction:\n* If it is the first node (n == 1), point head to this new node\n* If it is not the first node, point the next of the previous node to the current node `(ptr2->next = ptr1)`\n* ptr2 always tracks the last node, while ptr1 is used to create and read the data of the next node\nWhen the end mark is entered, set the next pointer of the last node of the linked list to NULL, indicating the end of the linked list.\n\n## Display and output the content\n```\nvoid display(struct Student *ptr) {\n\tprintf(\"Class    Student Number    Name                Course                Score: \\n\");\n\twhile (ptr != NULL) {\n        printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", ptr->clas, ptr->studentNum, ptr->name, ptr->course, ptr->score);\n        ptr = ptr->next;\n\t}\n\tprintf(\"\\n\");\n}\n```\nThe formal parameter of this function `struct Student *ptr` is a pointer to the \"Studen\" t structure, which serves as the entry point of the function and is used to receive the head node pointer of the linked list.\nWhen the pointer is not empty, loop is performed and student information is output in sequence.\n\n##Add and delete\n```\nvoid add(struct Student *ptr) {\n    struct Student *ptr1,*ptr2,*head;\n\thead = ptr;\n\tprintf(\"Enter the student information to add:\\n\");\n\twhile(ptr->next != NULL) ptr = ptr->next;\n\tptr1 = ptr2 = ptr;\n\tprintf(\"Class    Student Number    Name                Course                Score(enter 0 0 0 0 0 to end): \\n\");\n\tdo {\n\t\tptr1 = (struct Student*)malloc(LEN);\n\t\tscanf(\"%d%d%s%s%d\",&ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\t\tptr2->next = ptr1;\n\t\tptr2 = ptr1;\n\t} while(ptr1->studentNum != 0);\n\tptr2->next = NULL;\n\tdisplay(head);\n}\n\n// Delete function\nvoid delete(struct Student **head) {\n    int n;\n    printf(\"Enter the student number to delete: \\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head, *prev = NULL;\n\n    if (temp != NULL && temp->studentNum == n) {\n        *head = temp->next;\n        free(temp);\n        printf(\"Deleted the student information with student number %d\\n\", n);\n        printf(\"\\n\");\n        return;\n    }\n\n    while (temp != NULL && temp->studentNum != n) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) {\n        printf(\"Student with number %d not found\\n\", n);\n        printf(\"\\n\");\n        return;\n    }\n\n    prev->next = temp->next;\n\n    free(temp);\n\n    printf(\"Deleted the student information with student number %d\\n\", n);\n    printf(\"\\n\");\n    display(*head);\n}\n```\nThe \"do-while\" loop allows users to continuously input student information. Each loop will dynamically allocate a new \"Student\" structure memory through \"malloc\" and read the student information entered by the user through \"scanf\".\nFor newly entered student information, update the \"next\" pointer of the linked list, and add the newly allocated structure node to the end of the linked list. \"ptr2\" always points to the last node of the linked list.\nFinally set \"ptr2->next = NULL\" to ensure the linked list is terminated correctly, and delete this extra node outside the \"do-while\" loop\nSearch and delete:\n* If the head node is the node to be deleted, the function will update the head node pointer \"*head\" to point to the next node, then release the memory of the original head node, and notify the user that the student information has been deleted\n* If the head node is not the node to be deleted, the function will traverse the linked list until it finds the matching \"studentNum\" or reaches the end of the linked list. During the traversal process, the \"prev\" pointer is used to track the previous node of the current node, and \"temp\" Pointer keeps track of the node currently being examined\n* If no matching student number is found after traversing the entire linked list, the function will notify the user that the student with the specified student number is not found.\n* After finding the target node, adjust the next pointer of the previous node to bypass the current node \"temp\" and point directly to `temp->next`, thereby removing the current node from the linked list and then releasing the memory of the node\n\n## Check and modify\n```\nvoid search(struct Student *ptr) {\n    void searchByNumber(struct Student **head);\n\tvoid searchByName(struct Student **head);\n\tvoid searchByCourse(struct Student **head);\n\tint n;\n\tprintf(\"\\n\");\n\tprintf(\"Enter 1 for student number, 2 for name, 3 for course name search: \\n\");\n\tscanf(\"%d\",&n);\n\tswitch(n) {\n\tcase 1: searchByNumber(&ptr);break;\n\tcase 2: searchByName(&ptr);break;\n\tcase 3: searchByCourse(&ptr);break;\n\tdefault: printf(\"No such option!\\n\");\n\t}\n}\n\n// Search by student number\nvoid searchByNumber(struct Student **head) {\n    int n;\n    printf(\"\\nEnter the student number to search: \\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"Class    Student Number    Name                Course                Score: \\n\");\n    while (temp != NULL) {\n        if (temp->studentNum == n) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"Student with number %d not found\\n\", n);\n}\n\n// Search by name\nvoid searchByName(struct Student **head) {\n    char name[50];\n    printf(\"\\nEnter the name of the student to search: \\n\");\n    scanf(\"%50s\", name);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"Class    Student Number    Name                Course                Score: \\n\");\n    while (temp != NULL) {\n        if (strcmp(temp->name, name) == 0) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"Student named %s not found\\n\", name);\n}\n\n// Search by course\nvoid searchByCourse(struct Student **head) {\n    char course[50];\n    printf(\"\\nEnter the course to search: \\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"Class    Student Number    Name                Course                Score: \\n\");\n    while (temp != NULL) {\n        if (strcmp(temp->course, course) == 0) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"No students found for course %s\\n\", course);\n}\n\n// Modify function\nvoid modify(struct Student *ptr) {\n    void changeNumber(struct Student **head);\n\tvoid changeName(struct Student **head);\n\tvoid changeScore(struct Student **head);\n\tint n;\n\tprintf(\"\\n\");\n\tprintf(\"Enter 1 to change student number, 2 for name, 3 for score: \\n\");\n\tscanf(\"%d\",&n);\n\tswitch(n) {\n\tcase 1: changeNumber(&ptr);break;\n\tcase 2: changeName(&ptr);break;\n\tcase 3: changeScore(&ptr);break;\n\tdefault: printf(\"No such option!\\n\");\n\t}\n}\n\n// Change student number\nvoid changeNumber(struct Student **head) {\n    int oldNum, newNum;\n    printf(\"\\nEnter the old student number: \\n\");\n    scanf(\"%d\", &oldNum);\n    printf(\"\\nEnter the new student number: \\n\");\n    scanf(\"%d\", &newNum);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    while (temp != NULL) {\n        if (temp->studentNum == oldNum) {\n            temp->studentNum = newNum;\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"Student with number %d not found\\n\", oldNum);\n    else display(*head);\n}\n\n// Change name\nvoid changeName(struct Student **head) {\n    char name[50];\n    char newName[50];\n    printf(\"\\nEnter the current name: \\n\");\n    scanf(\"%50s\", name);\n    printf(\"\\nEnter the new name: \\n\");\n    scanf(\"%50s\", newName);\n\n    struct Student *temp = *head;\n\n    while (temp != NULL && strcmp(temp->name, name) != 0) temp = temp->next;\n\n    if (temp == NULL) printf(\"Student named %s not found\\n\", name);\n    else strcpy(temp->name, newName);\n    display(*head);\n}\n\n// Change score\nvoid changeScore(struct Student **head) {\n    int n, newScore;\n    printf(\"\\nEnter the student number to change score: \\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head;\n\n    while (temp != NULL && temp->studentNum != n) temp = temp->next;\n\n    if (temp == NULL) printf(\"Student with number %d not found\\n\", n);\n    else {\n        printf(\"\\nEnter the new score: \\n\");\n        scanf(\"%d\", &newScore);\n\n        temp->score = newScore;\n        printf(\"Updated score for student number %d to %d\\n\", temp->studentNum, newScore);\n    }\n    display(*head);\n}\n```\n\nBy traversing the linked list, compare each node to see if it is the same as the content to be queried.\nBy traversing the linked list, find the information that needs to be changed and replace the information that needs to be changed with new information.\n\n## Sort\n```\n// Sort function\nvoid sort(struct Student *head) {\n    char courseToSort[50];\n    printf(\"\\nPlease enter the course name to sort by score: \\n\");\n    scanf(\"%50s\", courseToSort);\n\n    struct Student *sortedList = createCourseList(head, courseToSort);\n\n    bubbleSort(&sortedList);\n\n    printf(\"Sorted: \\n\");\n    display(sortedList);\n\n    // Free sorted list\n    struct Student *temp;\n    while (sortedList != NULL) {\n        temp = sortedList;\n        sortedList = sortedList->next;\n        free(temp);\n    }\n}\n\n// Bubble sort function\nvoid bubbleSort(struct Student **head) {\n    int swapped;\n    struct Student *ptr1;\n    struct Student *lptr = NULL;\n\n    if (*head == NULL) return;\n\n    do {\n        swapped = 0;\n        ptr1 = *head;\n\n        while (ptr1->next != lptr) {\n            if (ptr1->score < ptr1->next->score) {\n                swap(ptr1, ptr1->next);\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    } while (swapped);\n}\n\n// Swap function\nvoid swap(struct Student *a, struct Student *b) {\n    int tempClass = a->clas;\n    int tempStudentNum = a->studentNum;\n    char tempName[50];\n    strcpy(tempName, a->name);\n    char tempCourse[50];\n    strcpy(tempCourse, a->course);\n    int tempScore = a->score;\n\n    a->clas = b->clas;\n    a->studentNum = b->studentNum;\n    strcpy(a->name, b->name);\n    strcpy(a->course, b->course);\n    a->score = b->score;\n\n    b->clas = tempClass;\n    b->studentNum = tempStudentNum;\n    strcpy(b->name, tempName);\n    strcpy(b->course, tempCourse);\n    b->score = tempScore;\n}\n\n// Create course list function\nstruct Student *createCourseList(struct Student *head, char *course) {\n    struct Student *newList = NULL, *temp, *newNode;\n    temp = head;\n    while (temp != NULL) {\n        if (strcmp(temp->course, course) == 0) {\n            newNode = (struct Student*)malloc(LEN);\n            *newNode = *temp;\n            newNode->next = newList;\n            newList = newNode;\n        }\n        temp = temp->next;\n    }\n    return newList;\n}\n```\nA new linked list is defined to store the sorted results through `struct Student *createSubjectList(struct Student *head, char *course);`\nThrough `void swap(struct Student *a, struct Student *b);`, a function is defined to exchange the positions of all information of two students, which facilitates the operation of swapping positions in bubble sorting.\nA bubble sort is defined through `void bubbleSort(struct Student **head);`, which is sorted by comparing scores.\nObtain the subjects that need to be sorted through `void sort(struct Student *head);`, store the subject information in the original linked list to the new linked list, sort the new linked list, and then output\n\n## Highest score and lowest score\n```\n// Maximum score function\nvoid maximum(struct Student *head) {\n    char course[50];\n    printf(\"\\nEnter the course to find the highest score: \\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *courseList = createCourseList(head, course), *temp;\n    int maxScore = -1;\n\n    temp = courseList;\n    while (temp != NULL) {\n        if (temp->score > maxScore) maxScore = temp->score;\n        temp = temp->next;\n    }\n\n    if (maxScore == -1) printf(\"No students found for course %s\\n\", course);\n    else printf(\"The highest score for %s is %d\\n\", course, maxScore);\n\n    // Free course list\n    while (courseList != NULL) {\n        temp = courseList;\n        courseList = courseList->next;\n        free(temp);\n    }\n}\n\n// Minimum score function\nvoid minimum(struct Student *head) {\n    char course[50];\n    printf(\"\\nEnter the course to find the lowest score: \\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *courseList = createCourseList(head, course), *temp;\n    int minScore = 101;\n\n    temp = courseList;\n    while (temp != NULL) {\n        if (temp->score < minScore) minScore = temp->score;\n        temp = temp->next;\n    }\n\n    if (minScore == 101) printf(\"No students found for course %s\\n\", course);\n    else printf(\"The lowest score for %s is %d\\n\", course, minScore);\n\n    // Free course list\n    while (courseList != NULL) {\n        temp = courseList;\n        courseList = courseList->next;\n        free(temp);\n    }\n}\n```\nObtain the subject for which the highest score needs to be queried, create a new linked list, store the subject information to be queried in the new linked list, compare in the new linked list, and obtain the highest score\nSame as the lowest score\n\n## Average score and passing rate\n```\n// Average score function\nvoid average(struct Student *head) {\n    char course[50];\n    printf(\"\\nEnter the course to calculate the average score: \\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *courseList = createCourseList(head, course), *temp;\n    int totalScore = 0, count = 0;\n\n    temp = courseList;\n    while (temp != NULL) {\n        totalScore += temp->score;\n        count++;\n        temp = temp->next;\n    }\n\n    if (count == 0) printf(\"No students found for course %s\\n\", course);\n    else printf(\"The average score for %s is %.2f\\n\", course, (float)totalScore / count);\n\n    // Free course list\n    while (courseList != NULL) {\n        temp = courseList;\n        courseList = courseList->next;\n        free(temp);\n    }\n}\n\n// Passing rate function\nvoid passingRate(struct Student *head) {\n    char course[50];\n    printf(\"\\nEnter the course to calculate the passing rate: \\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *courseList = createCourseList(head, course), *temp;\n    int passCount = 0, totalCount = 0;\n\n    temp = courseList;\n    while (temp != NULL) {\n        if (temp->score >= 60) passCount++;\n        totalCount++;\n        temp = temp->next;\n    }\n\n    if (totalCount == 0) printf(\"No students found for course %s\\n\", course);\n    else printf(\"The passing rate for %s is %.2f%%\\n\", course, ((float)passCount / totalCount) * 100);\n\n    // Free course list\n    while (courseList != NULL) {\n        temp = courseList;\n        courseList = courseList->next;\n        free(temp);\n    }\n}\n```\nObtain the subject for which the average score needs to be calculated, create a new linked list to store the information of the subject, calculate the total score and how many students there are, and finally output the average score\nPass rate is the same\n\n## source code\n```\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define MAX_COURSES 5\n#define LEN sizeof(struct Student)\n\n// Define student attributes\nstruct Student {\n\tint clas;\n\tint studentNum;\n\tchar name[50];\n\tchar course[50];\n\tint score;\n\tstruct Student *next;\n};\nstruct Student *create(void);\nvoid display(struct Student *ptr);\nvoid add(struct Student *ptr);\nvoid delete(struct Student **head);\nvoid search(struct Student *ptr);\nvoid searchByNumber(struct Student **head);\nvoid searchByName(struct Student **head);\nvoid searchByCourse(struct Student **head);\nvoid modify(struct Student *ptr);\nvoid changeNumber(struct Student **head);\nvoid changeName(struct Student **head);\nvoid changeScore(struct Student **head);\nvoid sort(struct Student *head);\nvoid bubbleSort(struct Student **head);\nvoid swap(struct Student *a, struct Student *b);\nstruct Student *createCourseList(struct Student *head, char *course);\nvoid maximum(struct Student *head);\nvoid minimum(struct Student *head);\nvoid average(struct Student *head);\nvoid passingRate(struct Student *head);\n\n// Main function\nint main(){\n    struct Student *head = NULL;\n    int choice;\n\n    while(1) {\n        printf(\"\\nStudent Information Management System\\n\");\n        printf(\"1. Create student information\\n\");\n        printf(\"2. Display all student information\\n\");\n        printf(\"3. Add student information\\n\");\n        printf(\"4. Delete student information\\n\");\n        printf(\"5. Search for student information\\n\");\n        printf(\"6. Modify student information\\n\");\n        printf(\"7. Sort students by score for a course\\n\");\n        printf(\"8. Highest score for a course\\n\");\n        printf(\"9. Lowest score for a course\\n\");\n        printf(\"10. Calculate average score for a course\\n\");\n        printf(\"11. Calculate passing rate for a course\\n\");\n        printf(\"0. Exit\\n\");\n        printf(\"Please enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch(choice) {\n            case 1: head = create();break;\n            case 2: display(head);break;\n            case 3: add(head);break;\n            case 4: delete(&head);break;\n            case 5: search(head);break;\n            case 6: modify(head);break;\n            case 7: sort(head);break;\n            case 8: maximum(head);break;\n            case 9: minimum(head);break;\n            case 10: average(head);break;\n            case 11: passingRate(head);break;\n            case 0: printf(\"Exiting system.\\n\"); return 0;\n            default: printf(\"Invalid option, please re-enter.\\n\");\n        }\n    }\n}\n\nstruct Student *create(void) {\n    struct Student *head;\n\tstruct Student *ptr1,*ptr2;\n\tint n = 0;\n\tprintf(\"Class    Student Number    Name                Course                Score(enter 0 0 0 0 0 to end): \\n\");\n\tptr1 = ptr2 = (struct Student*)malloc(LEN);\n\tscanf(\"%d%d%s%s%d\", &ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\thead = NULL;\n\twhile(ptr1->studentNum != 0) {\n\t\tn += 1;\n\t\tif(n == 1) head = ptr1;\n\t\telse ptr2->next = ptr1;\n\t\tptr2 = ptr1;\n\t\tptr1 = (struct Student*)malloc(LEN);\n\t\tscanf(\"%d%d%s%s%d\", &ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\t}\n\tptr2->next = NULL;\n\treturn(head);\n};\n\n// Display function\nvoid display(struct Student *ptr) {\n\tprintf(\"Class    Student Number    Name                Course                Score: \\n\");\n\twhile (ptr != NULL) {\n        printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", ptr->clas, ptr->studentNum, ptr->name, ptr->course, ptr->score);\n        ptr = ptr->next;\n\t}\n\tprintf(\"\\n\");\n}\n\n// Addition function\nvoid add(struct Student *ptr) {\n    struct Student *ptr1,*ptr2,*head;\n\thead = ptr;\n\tprintf(\"Enter the student information to add:\\n\");\n\twhile(ptr->next != NULL) ptr = ptr->next;\n\tptr1 = ptr2 = ptr;\n\tprintf(\"Class    Student Number    Name                Course                Score(enter 0 0 0 0 0 to end): \\n\");\n\tdo {\n\t\tptr1 = (struct Student*)malloc(LEN);\n\t\tscanf(\"%d%d%s%s%d\",&ptr1->clas, &ptr1->studentNum, ptr1->name, ptr1->course, &ptr1->score);\n\t\tptr2->next = ptr1;\n\t\tptr2 = ptr1;\n\t} while(ptr1->studentNum != 0);\n\tptr2->next = NULL;\n\tdisplay(head);\n}\n\n// Delete function\nvoid delete(struct Student **head) {\n    int n;\n    printf(\"Enter the student number to delete: \\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head, *prev = NULL;\n\n    if (temp != NULL && temp->studentNum == n) {\n        *head = temp->next;\n        free(temp);\n        printf(\"Deleted the student information with student number %d\\n\", n);\n        printf(\"\\n\");\n        return;\n    }\n\n    while (temp != NULL && temp->studentNum != n) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) {\n        printf(\"Student with number %d not found\\n\", n);\n        printf(\"\\n\");\n        return;\n    }\n\n    prev->next = temp->next;\n\n    free(temp);\n\n    printf(\"Deleted the student information with student number %d\\n\", n);\n    printf(\"\\n\");\n    display(*head);\n}\n\n// Search function\nvoid search(struct Student *ptr) {\n    void searchByNumber(struct Student **head);\n\tvoid searchByName(struct Student **head);\n\tvoid searchByCourse(struct Student **head);\n\tint n;\n\tprintf(\"\\n\");\n\tprintf(\"Enter 1 for student number, 2 for name, 3 for course name search: \\n\");\n\tscanf(\"%d\",&n);\n\tswitch(n) {\n\tcase 1: searchByNumber(&ptr);break;\n\tcase 2: searchByName(&ptr);break;\n\tcase 3: searchByCourse(&ptr);break;\n\tdefault: printf(\"No such option!\\n\");\n\t}\n}\n\n// Search by student number\nvoid searchByNumber(struct Student **head) {\n    int n;\n    printf(\"\\nEnter the student number to search: \\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"Class    Student Number    Name                Course                Score: \\n\");\n    while (temp != NULL) {\n        if (temp->studentNum == n) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"Student with number %d not found\\n\", n);\n}\n\n// Search by name\nvoid searchByName(struct Student **head) {\n    char name[50];\n    printf(\"\\nEnter the name of the student to search: \\n\");\n    scanf(\"%50s\", name);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"Class    Student Number    Name                Course                Score: \\n\");\n    while (temp != NULL) {\n        if (strcmp(temp->name, name) == 0) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"Student named %s not found\\n\", name);\n}\n\n// Search by course\nvoid searchByCourse(struct Student **head) {\n    char course[50];\n    printf(\"\\nEnter the course to search: \\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    printf(\"Class    Student Number    Name                Course                Score: \\n\");\n    while (temp != NULL) {\n        if (strcmp(temp->course, course) == 0) {\n            printf(\"%-10d%-10d%-20s%-20s%-10d\\n\", temp->clas, temp->studentNum, temp->name, temp->course, temp->score);\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"No students found for course %s\\n\", course);\n}\n\n// Modify function\nvoid modify(struct Student *ptr) {\n    void changeNumber(struct Student **head);\n\tvoid changeName(struct Student **head);\n\tvoid changeScore(struct Student **head);\n\tint n;\n\tprintf(\"\\n\");\n\tprintf(\"Enter 1 to change student number, 2 for name, 3 for score: \\n\");\n\tscanf(\"%d\",&n);\n\tswitch(n) {\n\tcase 1: changeNumber(&ptr);break;\n\tcase 2: changeName(&ptr);break;\n\tcase 3: changeScore(&ptr);break;\n\tdefault: printf(\"No such option!\\n\");\n\t}\n}\n\n// Change student number\nvoid changeNumber(struct Student **head) {\n    int oldNum, newNum;\n    printf(\"\\nEnter the old student number: \\n\");\n    scanf(\"%d\", &oldNum);\n    printf(\"\\nEnter the new student number: \\n\");\n    scanf(\"%d\", &newNum);\n\n    struct Student *temp = *head;\n    int found = 0;\n\n    while (temp != NULL) {\n        if (temp->studentNum == oldNum) {\n            temp->studentNum = newNum;\n            found = 1;\n        }\n        temp = temp->next;\n    }\n\n    if (!found) printf(\"Student with number %d not found\\n\", oldNum);\n    else display(*head);\n}\n\n// Change name\nvoid changeName(struct Student **head) {\n    char name[50];\n    char newName[50];\n    printf(\"\\nEnter the current name: \\n\");\n    scanf(\"%50s\", name);\n    printf(\"\\nEnter the new name: \\n\");\n    scanf(\"%50s\", newName);\n\n    struct Student *temp = *head;\n\n    while (temp != NULL && strcmp(temp->name, name) != 0) temp = temp->next;\n\n    if (temp == NULL) printf(\"Student named %s not found\\n\", name);\n    else strcpy(temp->name, newName);\n    display(*head);\n}\n\n// Change score\nvoid changeScore(struct Student **head) {\n    int n, newScore;\n    printf(\"\\nEnter the student number to change score: \\n\");\n    scanf(\"%d\", &n);\n\n    struct Student *temp = *head;\n\n    while (temp != NULL && temp->studentNum != n) temp = temp->next;\n\n    if (temp == NULL) printf(\"Student with number %d not found\\n\", n);\n    else {\n        printf(\"\\nEnter the new score: \\n\");\n        scanf(\"%d\", &newScore);\n\n        temp->score = newScore;\n        printf(\"Updated score for student number %d to %d\\n\", temp->studentNum, newScore);\n    }\n    display(*head);\n}\n\n// Sort function\nvoid sort(struct Student *head) {\n    char courseToSort[50];\n    printf(\"\\nPlease enter the course name to sort by score: \\n\");\n    scanf(\"%50s\", courseToSort);\n\n    struct Student *sortedList = createCourseList(head, courseToSort);\n\n    bubbleSort(&sortedList);\n\n    printf(\"Sorted: \\n\");\n    display(sortedList);\n\n    // Free sorted list\n    struct Student *temp;\n    while (sortedList != NULL) {\n        temp = sortedList;\n        sortedList = sortedList->next;\n        free(temp);\n    }\n}\n\n// Bubble sort function\nvoid bubbleSort(struct Student **head) {\n    int swapped;\n    struct Student *ptr1;\n    struct Student *lptr = NULL;\n\n    if (*head == NULL) return;\n\n    do {\n        swapped = 0;\n        ptr1 = *head;\n\n        while (ptr1->next != lptr) {\n            if (ptr1->score < ptr1->next->score) {\n                swap(ptr1, ptr1->next);\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    } while (swapped);\n}\n\n// Swap function\nvoid swap(struct Student *a, struct Student *b) {\n    int tempClass = a->clas;\n    int tempStudentNum = a->studentNum;\n    char tempName[50];\n    strcpy(tempName, a->name);\n    char tempCourse[50];\n    strcpy(tempCourse, a->course);\n    int tempScore = a->score;\n\n    a->clas = b->clas;\n    a->studentNum = b->studentNum;\n    strcpy(a->name, b->name);\n    strcpy(a->course, b->course);\n    a->score = b->score;\n\n    b->clas = tempClass;\n    b->studentNum = tempStudentNum;\n    strcpy(b->name, tempName);\n    strcpy(b->course, tempCourse);\n    b->score = tempScore;\n}\n\n// Create course list function\nstruct Student *createCourseList(struct Student *head, char *course) {\n    struct Student *newList = NULL, *temp, *newNode;\n    temp = head;\n    while (temp != NULL) {\n        if (strcmp(temp->course, course) == 0) {\n            newNode = (struct Student*)malloc(LEN);\n            *newNode = *temp;\n            newNode->next = newList;\n            newList = newNode;\n        }\n        temp = temp->next;\n    }\n    return newList;\n}\n\n// Maximum score function\nvoid maximum(struct Student *head) {\n    char course[50];\n    printf(\"\\nEnter the course to find the highest score: \\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *courseList = createCourseList(head, course), *temp;\n    int maxScore = -1;\n\n    temp = courseList;\n    while (temp != NULL) {\n        if (temp->score > maxScore) maxScore = temp->score;\n        temp = temp->next;\n    }\n\n    if (maxScore == -1) printf(\"No students found for course %s\\n\", course);\n    else printf(\"The highest score for %s is %d\\n\", course, maxScore);\n\n    // Free course list\n    while (courseList != NULL) {\n        temp = courseList;\n        courseList = courseList->next;\n        free(temp);\n    }\n}\n\n// Minimum score function\nvoid minimum(struct Student *head) {\n    char course[50];\n    printf(\"\\nEnter the course to find the lowest score: \\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *courseList = createCourseList(head, course), *temp;\n    int minScore = 101;\n\n    temp = courseList;\n    while (temp != NULL) {\n        if (temp->score < minScore) minScore = temp->score;\n        temp = temp->next;\n    }\n\n    if (minScore == 101) printf(\"No students found for course %s\\n\", course);\n    else printf(\"The lowest score for %s is %d\\n\", course, minScore);\n\n    // Free course list\n    while (courseList != NULL) {\n        temp = courseList;\n        courseList = courseList->next;\n        free(temp);\n    }\n}\n\n// Average score function\nvoid average(struct Student *head) {\n    char course[50];\n    printf(\"\\nEnter the course to calculate the average score: \\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *courseList = createCourseList(head, course), *temp;\n    int totalScore = 0, count = 0;\n\n    temp = courseList;\n    while (temp != NULL) {\n        totalScore += temp->score;\n        count++;\n        temp = temp->next;\n    }\n\n    if (count == 0) printf(\"No students found for course %s\\n\", course);\n    else printf(\"The average score for %s is %.2f\\n\", course, (float)totalScore / count);\n\n    // Free course list\n    while (courseList != NULL) {\n        temp = courseList;\n        courseList = courseList->next;\n        free(temp);\n    }\n}\n\n// Passing rate function\nvoid passingRate(struct Student *head) {\n    char course[50];\n    printf(\"\\nEnter the course to calculate the passing rate: \\n\");\n    scanf(\"%50s\", course);\n\n    struct Student *courseList = createCourseList(head, course), *temp;\n    int passCount = 0, totalCount = 0;\n\n    temp = courseList;\n    while (temp != NULL) {\n        if (temp->score >= 60) passCount++;\n        totalCount++;\n        temp = temp->next;\n    }\n\n    if (totalCount == 0) printf(\"No students found for course %s\\n\", course);\n    else printf(\"The passing rate for %s is %.2f%%\\n\", course, ((float)passCount / totalCount) * 100);\n\n    // Free course list\n    while (courseList != NULL) {\n        temp = courseList;\n        courseList = courseList->next;\n        free(temp);\n    }\n}\n```\n\n## chatgpt's review\nI fed this code to chatgpt and asked it to evaluate it. The evaluation results are as follows\n### advantage\n* Comprehensive functions: The program covers the core functions of the student information management system, such as adding, deleting, querying, sorting and statistics, etc., and comprehensively meets basic management needs.\n* Modular design: By splitting functions into multiple independent functions, the readability and maintainability of the code are improved. This modular design makes it easier to modify and extend individual functions.\n* Linked list data structure: Linked list is used to manage student information. Linked list is a dynamic data structure, which can effectively support dynamic addition and deletion operations of data, and memory usage is more flexible.\n### insufficient\n* Data persistence is not implemented: the program does not provide a data persistence mechanism, all data is stored in memory, and the data will be lost after the program is closed. This is a significant drawback in practical applications.\n* Error handling needs to be strengthened: The program has insufficient fault tolerance in the event of input errors or exceptions, and does not provide sufficient error handling mechanisms, which may cause the program to exit abnormally or runtime errors.\n* Simple interface interaction: Although the graphical interface is not considered, the command line interaction interface of the program is still relatively simple, lacking guidance and input prompts, which may affect the user experience.\n* Efficiency issues: When processing large amounts of data, using simple linked list structures and basic sorting algorithms may not be efficient, especially for sorting and search functions.\n### Suggestions for Improvement\n* Introduce data persistence: achieve persistent storage of data by saving data to files (such as text files, CSV files, etc.). Load the data in the file when the program starts and save the data to the file when exiting to ensure that the data will not be lost when the program is closed.\n* Enhanced error handling and input validation: Strictly verify user input to ensure the legality and correctness of the input data. Predict and handle potential error situations to improve program stability and fault tolerance.\n* Optimize data structures and algorithms: For large amounts of data, you can consider using more efficient data structures (such as hashing, balanced trees, etc.) to manage data. At the same time, for operations such as sorting and searching, more efficient algorithms (such as quick sort, binary search, etc.) are used to improve performance.\n* Improved user interaction design: Even in the command line interface, the user experience can be improved through more friendly prompt information, clear operation guidance, and simplified operation steps. For example, provide clear feedback on the success or error of an operation and simplify the complex input process.\n","tags":["CS","C"]},{"title":"至暗时刻/Darkest Hour","url":"/2024/04/09/至暗时刻-Darkest-Hour/","content":"# 至暗时刻\n\n2024年4月8下午3:18可以在北美部分区域看到日全食，很幸运我就在能看到的区域之一--汉密尔顿\n早上起床的时候，拉开窗帘，那天上的云厚的感觉有个人发誓就能批个雷下来。那股子失落劲(;´༎ຶД༎ຶ)。在天气预报上找了好几个区域都是多云天气，本来都打算出发去其他地方看了，但是人懒(－_－) zzZ，就想赌一下，看看能不能有机会天晴一下。\n结果很美妙，下午两点多的时候出门，云已经很少，就算有也很薄，完全遮不住太阳光线，（我的赌运真不错(≧ω≦)），本来只想在宿舍楼地下随便拍一下的，刚好遇到我室友，就把我带去旁边露天体育场了，人真多，很多不是我们学校的人都来了，搁那调试相机和手机拍摄角度调了好久，还为了架住手机又跑回宿舍拿手机夹去了（结果最后还是没用上，完全架不稳还是得靠手拿着）。\n在日全食的瞬间，整个体育场的人都在欢呼，可热闹了，虽然没有我想的那种像关了灯的那种效果，不过确实很明显的天色暗了下来，还很冷°.°·(((p(≧□≦)q)))·°.°，在日全食的某几秒钟，有个小亮点，搭配上周围的环就像是一枚钻戒一样，特好看(′▽`ʃ♡ƪ)。![“钻戒”日全食](/img/ring.jpg)\n有几个在多伦多的朋友，多伦多看不见日全食，据说好像是99%日食，我以为差距不是很大，但他们跟我说没有感觉到天黑下来的感觉，emmmmmm，那差距确实挺大的，拍了几段视频给他们分享分享，就被“偷了”(*￣︿￣)，介于本人并不会剪视频，这个重任也就交给了他们，还不错，我挺满意♪(^∇^*)。\n\n<video controls>\n  <source src=\"/video/solarec.mp4\" type=\"video/mp4\">\n</video>\n\n## 番外\n\n回宿舍后，本来想点给日本拉面外卖的，结果他们今天太忙了，不接外卖的单(ノへ￣、)，在找想吃啥的时候看到一家甜品店（也许是吧），叫Hi Yogurt，点了一杯猕猴桃酸奶，一份马卡龙拼盘，味道都挺不错，就是马卡龙实在太甜了一点(￣ェ￣;)。 ![甜点](/img/hiyogurt.jpg)\n\n------------------\n\n# Darkest Hour\n\nThe total solar eclipse can be seen in some areas of North America at 3:18 pm on April 8, 2024. Fortunately, I am in one of the areas where it can be seen - Hamilton\nWhen I got up in the morning and opened the curtains, the clouds in the sky were so thick that someone swore they could make them come down. That feeling of loss of energy(;´༎ຶД༎ຶ). I found cloudy weather in several areas in the weather forecast. I originally planned to go to other places to see, but I was too lazy (-_-) zzZ, so I just wanted to take a gamble and see if there would be a chance for clear skies.\nThe result was wonderful. When I went out at about two o'clock in the afternoon, there were very few clouds. Even if there were any, they were very thin and could not block the sun's rays at all. (My gambling luck is really good (≧ω≦)). I originally wanted to stay in the dormitory building I just took a random photo underground. I happened to meet my roommate, so he took me to the outdoor stadium next to it. There were so many people, many of whom were not from our school. I left the camera and mobile phone to adjust the shooting angle for a long time. I held the phone up and ran back to the dormitory to get the phone holder (it turned out to be useless in the end, the stand was completely unstable and I still had to hold it with my hands).\nAt the moment of the total solar eclipse, people in the entire stadium were cheering, and it was very lively. Although it didn't have the effect of turning off the lights as I thought, it was indeed obviously dark and very cold.°. ·(((p(≧□≦)q)))·°.°, during certain seconds of the total solar eclipse, there is a small bright spot, which looks like a diamond ring when paired with the surrounding rings. It looks very nice(′ ▽`ʃ♡ƪ). ![ring](/img/ring.jpg)\nI have a few friends in Toronto who can’t see a total solar eclipse in Toronto. It’s said to be a 99% solar eclipse. I thought the difference wasn’t very big, but they told me they didn’t feel it getting dark. Emmmmmm, the difference is indeed quite big. Yes, I took a few videos to share with them, and they were \"stolen\" (*￣︿￣). Since I don't know how to edit videos, I gave them this important task. It's not bad, I'm quite satisfied♪ (^∇^*).\n\n<video controls>\n  <source src=\"/video/solarec.mp4\" type=\"video/mp4\">\n</video>\n\n## Extra\n\nAfter returning to the dormitory, I originally wanted to order Japanese ramen takeout, but they were too busy today and did not take takeout orders (ノへ￣,). When I was looking for what I wanted to eat, I saw a dessert shop (maybe). I called Hi Yogurt and ordered a cup of kiwi yogurt and a macaron platter. They tasted pretty good, but the macarons were a little too sweet (￣ェ￣;). ![dessert](/img/hiyogurt.jpg)\n","tags":["Life","Food"]},{"title":"个人博客搭建实录/Personal Blog Building Record","url":"/2024/04/02/个人博客搭建实录-Personal-blog-building-record/","content":"# 个人博客搭建实录\n我查阅了许多搭建个人博客的框架，最终选择了hexo，由于不是很想花钱决定挂载到GitHub上。\n\n## 创建仓库\n首先是在GitHub上创建了一个新的仓库(Repository)，命名为“用户名.github.io”，我自己的就命名为“7uck9f0x.github.io”，然后选择开源(Public)，然后将.gitignore文件设置为Node，仓库就创建完成啦。\n\n## 准备搭建环境，安装Node.js和Git\n```\nsudo apt install nodejs\nsudo apt install npm\nsudo apt install git\n```\n\n## 连接到GitHub\n```\ngit config --global user.name “github username”\ngit config --global user.email “github email”\n```\n我自己的就是\n```\ngit config --global user.name “7uck9f0x”\ngit config --global user.email “7uck9f0x@gmail.com”\n```\n\n## 创建SSH密钥\n```\nssh-keygen -t rsa -C “github email”\n```\n我自己的就是\n```\nssh-keygen -t rsa -C “7uck9f0x@gmail.com”\n```\n然后一直回车就可以了\n生成了密钥后在保存密钥的地址找到`id_rsa.pub`，里面的是公钥，复制里面的内容，在GitHub的设置里找到`SSH和GPG密钥(SSH and GPG keys)`，选择创建新的SSH密钥，将复制的内容粘贴到`key`部分，`title`随便取一个就可以 \n在使用`Ssh-keygen -t rsa -C “github email” `的时候记得注意保存的地址，我最开始时是存在了/home路径下，后来觉得麻烦就把用户切到管理员，就一直在root目录操作，后来在关联的时候就一直读取不到密钥(つд⊂)，然后又重新生成了一个密钥才读取连接成功的\n在控制终端输入`ssh -T git@github.com` 出现 “Are you sure…”输入yes回车就好了，最后弹出“Hi, xxx! You’ve successfully… ” 就是连接成功了\n\n## 安装Hexo博客程序\n首先先创建一个文件架用来存放Hexo的程序文件，我是创建在了`/var/www/hexo`，然后进入到这个目录里，使用npm一键安装Hexo\n```\nnpm install -g hexo-cli\n```\n安装完成后初始化并安装组件\n```\nhexo init\nnpm install\n```\n完成后就可以生成页面并进行预览了\n```\nhexo g\nhexo s\n```\n然后就可以访问https://localhost:4000, 出现默认页面，本地博客就安装成功了(^▽^)\n\n## 上传部署\n然后就可以将Hexo部署到GitHub的page上了(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\n首先需要安装hexo-deployer-git\n```\nnpm install hexo-deployer-git --save\n```\n然后将_config.yml文件中的Deployment部分修该如下\n```\ndeploy:\n\ttype: git\n\trepository: git@github.com:用户名/用户名.github.io.git\n\tbranch: main\n```\n最后运行`hexo d`就把网页上传部署到github上了，~~完结撒花(≧∇≦)/~~\n\n## 博客主题修改\nhexo的初始界面我不是很喜欢，就在hexo官网上浏览了好多主题，都很好看，我最后选择使用AirCloud感觉比较简洁还挺好看的\n在选择好想要的主题后点击可以直接跳转到GitHub，里面有很详细的换主题的教程，直接跟着做就好了，我尝试了挺多个的，基本流程都差不多直接用`git clone https://github.com/……` 就可以了。一般都是直接下载保存hexo文件的文件夹里的themes文件夹，不过有一些是直接保存在了hexo文件夹，如果是这种情况进入到这个文件夹里找到这个文件夹的themes复制到自己的themes就可以了，最后再到_config.yml将theme更改就ok了。我自己的就是在用使用`git clone https://github.com/aircloud/hexo-aircloud-blog.git --recursive` 后直接保存在了 `/var/www/hexo`文件夹里叫`hexo-air-blog` 再到这个文件夹里找到themes复制到我自己的themes里的，在更改完后记得要重新上传部署到GitHub\n正式完结撒花(^▽^)/★*☆♪\n\n------------------\n\n# Personal blog building record\nI checked out many frameworks for building a personal blog, and finally chose hexo. Since I didn’t want to spend money, I decided to mount it on GitHub.\n\n## Create repository\nFirst, create a new repository (Repository) on GitHub and name it \"username.github.io\". I named my own \"7uck9f0x.github.io\", then select Open Source (Public), and then The .gitignore file is set to Node, and the warehouse is created.\n\n## Prepare to build the environment and install Node.js and Git\n```\nsudo apt install nodejs\nsudo apt install npm\nsudo apt install git\n```\n\n## Connect to GitHub\n```\ngit config --global user.name \"github username\"\ngit config --global user.email \"github email\"\n```\nMy own is\n```\ngit config --global user.name \"7uck9f0x\"\ngit config --global user.email \"7uck9f0x@gmail.com\"\n```\n\n## Create SSH key\n```\nssh-keygen -t rsa -C \"github email\"\n```\nMy own is\n```\nssh-keygen -t rsa -C \"7uck9f0x@gmail.com\"\n```\nThen just press Enter\nAfter generating the key, find `id_rsa.pub` at the address where the key is saved. The public key is inside. Copy the contents. Find `SSH and GPG keys (SSH and GPG keys)` in GitHub settings and select Create a new SSH key, paste the copied content into the `key` section, and select any `title`\nWhen using `Ssh-keygen -t rsa -C \"github email\" `, remember to pay attention to the saved address. At first, it existed in the /home path. Later, I found it troublesome and switched the user to the administrator. It has been there ever since. When operating the root directory, I could not read the key (つд⊂) during the association. Then I regenerated a key before reading and connecting successfully.\nEnter `ssh -T git@github.com` in the control terminal, and \"Are you sure...\" will appear. Just enter yes and press Enter. Finally, \"Hi, xxx! You've successfully...\" will pop up, indicating that the connection is successful.\n\n## Install Hexo blog program\nFirst create a file shelf to store Hexo program files. I created it in `/var/www/hexo`, then enter this directory and use npm to install Hexo with one click.\n```\nnpm install -g hexo-cli\n```\nAfter the installation is complete, initialize and install components\n```\nhexo init\nnpm install\n```\nOnce completed, you can generate the page and preview it.\n```\nhexo g\nhexos\n```\nThen you can visit https://localhost:4000, the default page will appear, and the local blog is successfully installed (^▽^)\n\n## Upload deployment\nThen you can deploy Hexo to the GitHub page (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\nFirst you need to install hexo-deployer-git\n```\nnpm install hexo-deployer-git --save\n```\nThen modify the Deployment part in the _config.yml file as follows\n```\ndeploy:\n\ttype: git\n\trepository: git@github.com:username/username.github.io.git\n\tbranch: main\n```\nFinally, run `hexo d` to upload and deploy the web page to github, ~~Finished (≧∇≦)/~~\n\n## Blog theme modification\nI don’t like the initial interface of hexo very much. I browsed many themes on the hexo official website and they are all very good-looking. I finally chose to use AirCloud, which I found to be relatively simple and good-looking.\nAfter selecting the theme you want, click to jump directly to GitHub. There is a very detailed tutorial on changing the theme. Just follow it. I have tried many, and the basic process is almost the same. Just use `git clone https://github.com/…` will do. Generally, you download directly the themes folder in the folder where the hexo file is saved, but some are directly saved in the hexo folder. If this is the case, go into this folder and find the themes in this folder and copy it to your own. Just go to themes and finally go to _config.yml to change the theme and it will be ok. I use `git clone https://github.com/aircloud/hexo-aircloud-blog.git --recursive` and save it directly in the `/var/www/hexo` folder called `hexo -air-blog` Then find the themes in this folder and copy them to my own themes. After making changes, remember to re-upload and deploy to GitHub.\nOfficially finished with flowers (^▽^)/★*☆♪\n","tags":["CS","Linux"]},{"title":"FirstPost","url":"/2024/04/01/FirstPost/","content":"\n# 第一个帖子\n\n这是我的第一个帖子，2024年3月31日自己搭建了这个博客，其间遇到挺多困难的，像是key的路径不对，hexo主题不会更换等问题，不过好在最终都解决了，这些问题并没有阻挡我搭建这个博客，很开心。\n\n以后可能会在该博客里分享一些生活，学习心得或者一些想说的话吧UwU\n\n------------------\n\n# First Post\n\nThis is my first post. I built this blog on March 31, 2024. I encountered many difficulties during the process, such as the key path was wrong, the hexo theme would not change, etc., but fortunately, they were all solved in the end. Well, these problems did not stop me from setting up this blog, and I am very happy.\n\nIn the future, I may share some life, learning experience or what I want to say in this blog UwU\n"}]